# W25Q128
个人笔记
/*数据组织
W25Q128地址布局：
+------------------+
| 文件头(3字节)    | <- Address
+------------------+
| 第1帧(1024字节)  | <- Address + 3
+------------------+
| 第2帧(1024字节)  | <- Address + 1027
+------------------+
| ...              |
+------------------+*/
	/*1.为什么帧数量需要两字节？
		1个字节=8位=255帧，成千上万帧的视频255不够。
		2个字节=65535帧max。低八位，高八位
	小端格式（低位先存高位后存）如果大端格式，需要俩颠倒一下。
		eg.1000帧  temp[1] = 1000&0xFF  			  低八位=0xE8（232）
					temp[2] = (1000>>8) &0xFF		  高八位=0x03（3）
					1000=3×256+232
				//恢复帧数
					frames=（temp[2]<<8)|temp[1]
							//= (0x03 << 8) | 0xE8 
							= 0x0300 | 0xE8 
							= 0x03E8 = 1000//
	  2.为什么用0xAA作为魔术字标识-10101010b，好识别。随机数据很少恰好为0xAA
			// 场景1：有效的视频文件 W25Q128地址0: 0xAA 0xE8 0x03 ...  // 识别为视频文件，正常播放

			// 场景2：未初始化的Flash区域  W25Q128地址0: 0xFF 0xFF 0xFF ...  // 擦除状态，不是视频文件

			// 场景3：随机数据  W25Q128地址0: 0x12 0x34 0x56 ...  // 不是0xAA，识别为无效文件
	
		3.完整流程：定义文件头数组=调用函数读取数据【0xAA错误处理】，头文件数组被0xAA和低高八位数据赋值=播放逻辑（oledmodww
		4.单位
		    帧1024个8位插排=1024字节00000000=8192位0/1；128*64/8=1024字节=1帧
		5.位运算
		   或：只要一位为0，结果位=0 1000&0xFF作为滤嘴取低八位。---高八位的&0xFF完全可以省略，因为前面总是0.		   1000的二进制：00000011 11101000  （16位表示）
			0xFF的二进制：00000000 11111111  （16位表示）

			按位与运算：
			00000011 11101000  (1000)&
			00000000 11111111  (0xFF)= 
			00000000 11101000  (232)
			移位：a>>b
			将a向右移动b位≈a/256；低位都会舍弃。左移乘，如果数据类型容量不够，高位舍弃，如果够，那么低位会补0
		6.帧数，数据量（所有帧占用的存储空间）
		假设制作一个3秒视频：
	帧率：25帧/秒
	总帧数：3 × 25 = 75帧
	每帧大小：1024字节
	总数据量：75 × 1024 = 76,800字节
	存储到W25Q128：
	// 文件头计算：
		uint16_t frames = 75;
		uint8_t temp[3] = {0xAA, frames & 0xFF, (frames >> 8) & 0xFF};
		// temp[0] = 0xAA, temp[1] = 75, temp[2] = 0

	// 写入文件头
		W25Q128_unlimited_Program(0, temp, 3);

	// 写入75帧视频数据
		for(int i = 0; i < 75; i++) {
								// 每帧1024字节
			W25Q128_unlimited_Program(3 + i*1024, frame_data[i], 1024);}	
	*/
